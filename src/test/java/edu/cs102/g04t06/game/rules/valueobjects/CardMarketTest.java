package edu.cs102.g04t06.game.rules.valueobjects;

import edu.cs102.g04t06.game.rules.entities.Card;
import edu.cs102.g04t06.game.rules.entities.GemColor;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

// Generated by GPT-5 (Codex)
/**
 * Unit tests for CardMarket value object.
 *
 */
@DisplayName("CardMarket Tests")
class CardMarketTest {

    private static final int MIN_DECK_SIZE = 20;

    @Test
    @DisplayName("Test constructor for failure")
    void constructorShouldThrowErrorWithCardsLessThanTwenty() {
        List<Card> level1Cards = createCards(1, 19);
        List<Card> level2Cards = createCards(2, MIN_DECK_SIZE);
        List<Card> level3Cards = createCards(3, MIN_DECK_SIZE);

        assertThrows(IllegalArgumentException.class,
                () -> new CardMarket(level1Cards, level2Cards, level3Cards));
    }

    @Test
    @DisplayName("Constructor should split visible and hidden cards correctly")
    void constructorShouldCreateVisibleAndDeckCards() {
        CardMarket market = createStandardMarket();

        assertEquals(4, market.getVisibleCards(1).size());
        assertEquals(16, market.getDeckSize(1));
        assertEquals(4, market.getVisibleCards(2).size());
        assertEquals(16, market.getDeckSize(2));
        assertEquals(4, market.getVisibleCards(3).size());
        assertEquals(16, market.getDeckSize(3));
    }

    @Test
    @DisplayName("getVisibleCards should throw for invalid level")
    void getVisibleCardsShouldThrowForInvalidLevel() {
        CardMarket market = createStandardMarket();

        assertThrows(IllegalArgumentException.class, () -> market.getVisibleCards(0));
        assertThrows(IllegalArgumentException.class, () -> market.getVisibleCards(4));
    }

    @Test
    @DisplayName("getVisibleCard should throw for invalid index")
    void getVisibleCardShouldThrowForInvalidIndex() {
        CardMarket market = createStandardMarket();

        assertThrows(IllegalArgumentException.class, () -> market.getVisibleCard(1, -1));
        assertThrows(IllegalArgumentException.class, () -> market.getVisibleCard(1, 4));
    }

    @Test
    @DisplayName("drawCard should reduce deck size")
    void drawCardShouldReduceDeckSize() {
        CardMarket market = createStandardMarket();
        int before = market.getDeckSize(1);

        Card drawnCard = market.drawCard(1);

        assertNotNull(drawnCard);
        assertEquals(before - 1, market.getDeckSize(1));
    }

    @Test
    @DisplayName("drawCard should throw when deck is empty")
    void drawCardShouldThrowWhenDeckEmpty() {
        CardMarket market = createStandardMarket();
        for (int i = 0; i < 16; i++) {
            market.drawCard(1);
        }

        assertEquals(0, market.getDeckSize(1));
        assertThrows(IllegalArgumentException.class, () -> market.drawCard(1));
    }

    @Test
    @DisplayName("removeCard should refill visible cards when deck has cards")
    void removeCardShouldRefillVisibleCards() {
        CardMarket market = createStandardMarket();
        int beforeVisibleSize = market.getVisibleCards(1).size();
        int beforeDeckSize = market.getDeckSize(1);

        market.removeCard(1, 0);

        assertEquals(beforeVisibleSize, market.getVisibleCards(1).size());
        assertEquals(beforeDeckSize - 1, market.getDeckSize(1));
    }

    @Test
    @DisplayName("removeCard should reduce visible cards when deck is empty")
    void removeCardShouldShrinkVisibleWhenDeckEmpty() {
        CardMarket market = createStandardMarket();
        for (int i = 0; i < 16; i++) {
            market.drawCard(1);
        }

        market.removeCard(1, 0);

        assertEquals(3, market.getVisibleCards(1).size());
        assertEquals(0, market.getDeckSize(1));
    }

    @Test
    @DisplayName("removeCard should throw for invalid index")
    void removeCardShouldThrowForInvalidIndex() {
        CardMarket market = createStandardMarket();

        assertThrows(IllegalArgumentException.class, () -> market.removeCard(1, -1));
        assertThrows(IllegalArgumentException.class, () -> market.removeCard(1, 5));
    }

    @Test
    @DisplayName("visible cards should match requested level")
    void visibleCardsShouldBelongToRequestedLevel() {
        CardMarket market = createStandardMarket();

        List<Card> level2VisibleCards = market.getVisibleCards(2);
        assertEquals(4, level2VisibleCards.size());
        assertTrue(level2VisibleCards.stream().allMatch(card -> card.getLevel() == 2));
    }

    private CardMarket createStandardMarket() {
        return new CardMarket(
                createCards(1, MIN_DECK_SIZE),
                createCards(2, MIN_DECK_SIZE),
                createCards(3, MIN_DECK_SIZE)
        );
    }

    private List<Card> createCards(int level, int count) {
        List<Card> cards = new ArrayList<>();
        Cost standardCost = createStandardCost();
        for (int i = 0; i < count; i++) {
            cards.add(new Card(level, i % 3, GemColor.WHITE, standardCost));
        }
        return cards;
    }

    private Cost createStandardCost() {
        Map<GemColor, Integer> costMap = new EnumMap<>(GemColor.class);
        costMap.put(GemColor.WHITE, 2);
        return new Cost(costMap);
    }
}
