package edu.cs102.g04t06.game.rules.valueobjects;

import edu.cs102.g04t06.game.rules.entities.Card;
import edu.cs102.g04t06.game.rules.entities.GemColor;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;

import java.util.ArrayList;
import java.util.EnumMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

// Generated by Claude Sonnet 4.5
/**
 * Unit tests for Cost value object.
 * 
 * @author CS102 Team G6
 * @version 1.0
 */
@DisplayName("CardMarket Tests")
class CardMarketTest {
    
    private List<Card> level1Cards;
    private List<Card> level2Cards;
    private List<Card> level3Cards;
    private CardMarket market;
    private Cost standardCost;
    
    @BeforeEach
    void setUp() {
        // Create standard cost
        Map<GemColor, Integer> costMap = new EnumMap<>(GemColor.class);
        costMap.put(GemColor.WHITE, 2);
        standardCost = new Cost(costMap);
        
        // Create 10 cards for each level
        level1Cards = createCards(1, 10);
        level2Cards = createCards(2, 10);
        level3Cards = createCards(3, 10);
        
        // Create market
        market = new CardMarket(level1Cards, level2Cards, level3Cards);
    }
    
    /**
     * Helper method to create a list of cards for testing
     */
    private List<Card> createCards(int level, int count) {
        List<Card> cards = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            cards.add(new Card(level, i, GemColor.WHITE, standardCost));
        }
        return cards;
    }
    
    // ==================== Constructor Tests ====================
    
    @Test
    @DisplayName("Constructor should create market with 4 visible cards per level")
    void constructorShouldCreate4VisibleCardsPerLevel() {
        assertEquals(4, market.getVisibleCards(1).size());
        assertEquals(4, market.getVisibleCards(2).size());
        assertEquals(4, market.getVisibleCards(3).size());
    }
    
    @Test
    @DisplayName("Constructor should create decks with remaining cards")
    void constructorShouldCreateDecksWithRemainingCards() {
        // 10 cards total - 4 visible = 6 in deck
        assertEquals(6, market.getDeckSize(1));
        assertEquals(6, market.getDeckSize(2));
        assertEquals(6, market.getDeckSize(3));
    }
    
    @Test
    @DisplayName("Constructor should shuffle cards (visible cards are different across instances)")
    void constructorShouldShuffleCards() {
        // Create fresh card lists (same content)
        List<Card> fresh1 = createCards(1, 10);
        List<Card> fresh2 = createCards(2, 10);
        List<Card> fresh3 = createCards(3, 10);
        
        // Create multiple markets
        CardMarket market1 = new CardMarket(
            new ArrayList<>(fresh1), 
            new ArrayList<>(fresh2), 
            new ArrayList<>(fresh3)
        );
        
        CardMarket market2 = new CardMarket(
            new ArrayList<>(fresh1), 
            new ArrayList<>(fresh2), 
            new ArrayList<>(fresh3)
        );
        
        CardMarket market3 = new CardMarket(
            new ArrayList<>(fresh1), 
            new ArrayList<>(fresh2), 
            new ArrayList<>(fresh3)
        );
        
        // Get first visible card from each market
        Card market1Card = market1.getVisibleCard(1, 0);
        Card market2Card = market2.getVisibleCard(1, 0);
        Card market3Card = market3.getVisibleCard(1, 0);
        
        // At least one should be different (probabilistically almost certain)
        // If all three are the same, shuffle is not working
        boolean atLeastOneDifferent = 
            market1Card != market2Card || 
            market2Card != market3Card || 
            market1Card != market3Card;
        
        assertTrue(atLeastOneDifferent, 
            "Shuffle should produce different arrangements across multiple market instances");
    }
    
    @Test
    @DisplayName("Constructor should handle exactly 4 cards (no deck)")
    void constructorShouldHandleExactly4Cards() {
        List<Card> exactly4 = createCards(1, 4);
        List<Card> level2 = createCards(2, 10);
        List<Card> level3 = createCards(3, 10);
        
        CardMarket smallMarket = new CardMarket(exactly4, level2, level3);
        
        assertEquals(4, smallMarket.getVisibleCards(1).size());
        assertEquals(0, smallMarket.getDeckSize(1));
    }
    
    @Test
    @DisplayName("Constructor should handle fewer than 4 cards")
    void constructorShouldHandleFewerThan4Cards() {
        List<Card> only2 = createCards(1, 2);
        List<Card> level2 = createCards(2, 10);
        List<Card> level3 = createCards(3, 10);
        
        CardMarket smallMarket = new CardMarket(only2, level2, level3);
        
        assertEquals(2, smallMarket.getVisibleCards(1).size());
        assertEquals(0, smallMarket.getDeckSize(1));
    }
    
    @Test
    @DisplayName("Constructor should handle empty card list")
    void constructorShouldHandleEmptyCardList() {
        List<Card> empty = new ArrayList<>();
        List<Card> level2 = createCards(2, 10);
        List<Card> level3 = createCards(3, 10);
        
        CardMarket emptyMarket = new CardMarket(empty, level2, level3);
        
        assertEquals(0, emptyMarket.getVisibleCards(1).size());
        assertEquals(0, emptyMarket.getDeckSize(1));
    }
    
    // ==================== getVisibleCards() Tests ====================
    
    @Test
    @DisplayName("getVisibleCards should return 4 cards for each level")
    void getVisibleCardsShouldReturn4CardsPerLevel() {
        assertEquals(4, market.getVisibleCards(1).size());
        assertEquals(4, market.getVisibleCards(2).size());
        assertEquals(4, market.getVisibleCards(3).size());
    }
    
    @Test
    @DisplayName("getVisibleCards should return defensive copy")
    void getVisibleCardsShouldReturnDefensiveCopy() {
        List<Card> visible = market.getVisibleCards(1);
        int originalSize = visible.size();
        
        // Modify returned list
        visible.clear();
        
        // Market should be unchanged
        assertEquals(originalSize, market.getVisibleCards(1).size());
    }
    
    @Test
    @DisplayName("getVisibleCards should return empty list for invalid level")
    void getVisibleCardsShouldReturnEmptyForInvalidLevel() {
        assertEquals(0, market.getVisibleCards(0).size());
        assertEquals(0, market.getVisibleCards(4).size());
        assertEquals(0, market.getVisibleCards(-1).size());
    }
    
    @Test
    @DisplayName("getVisibleCards should return non-null list")
    void getVisibleCardsShouldReturnNonNull() {
        assertNotNull(market.getVisibleCards(1));
        assertNotNull(market.getVisibleCards(2));
        assertNotNull(market.getVisibleCards(3));
    }
    
    // ==================== getVisibleCard() Tests ====================
    
    @Test
    @DisplayName("getVisibleCard should return correct card at index")
    void getVisibleCardShouldReturnCorrectCard() {
        Card card0 = market.getVisibleCard(1, 0);
        Card card1 = market.getVisibleCard(1, 1);
        Card card2 = market.getVisibleCard(1, 2);
        Card card3 = market.getVisibleCard(1, 3);
        
        assertNotNull(card0);
        assertNotNull(card1);
        assertNotNull(card2);
        assertNotNull(card3);
        
        // All should be different cards
        assertNotSame(card0, card1);
        assertNotSame(card1, card2);
        assertNotSame(card2, card3);
    }
    
    @Test
    @DisplayName("getVisibleCard should return null for invalid index")
    void getVisibleCardShouldReturnNullForInvalidIndex() {
        assertNull(market.getVisibleCard(1, -1));
        assertNull(market.getVisibleCard(1, 4));
        assertNull(market.getVisibleCard(1, 100));
    }
    
    @Test
    @DisplayName("getVisibleCard should return null for invalid level")
    void getVisibleCardShouldReturnNullForInvalidLevel() {
        assertNull(market.getVisibleCard(0, 0));
        assertNull(market.getVisibleCard(4, 0));
        assertNull(market.getVisibleCard(-1, 0));
    }
    
    @Test
    @DisplayName("getVisibleCard should handle all valid indices (0-3)")
    void getVisibleCardShouldHandleAllValidIndices() {
        for (int i = 0; i < 4; i++) {
            assertNotNull(market.getVisibleCard(1, i));
            assertNotNull(market.getVisibleCard(2, i));
            assertNotNull(market.getVisibleCard(3, i));
        }
    }
    
    // ==================== getDeckSize() Tests ====================
    
    @Test
    @DisplayName("getDeckSize should return correct size for each level")
    void getDeckSizeShouldReturnCorrectSize() {
        assertEquals(6, market.getDeckSize(1));
        assertEquals(6, market.getDeckSize(2));
        assertEquals(6, market.getDeckSize(3));
    }
    
    @Test
    @DisplayName("getDeckSize should return 0 for invalid level")
    void getDeckSizeShouldReturnZeroForInvalidLevel() {
        assertEquals(0, market.getDeckSize(0));
        assertEquals(0, market.getDeckSize(4));
        assertEquals(0, market.getDeckSize(-1));
    }
    
    @Test
    @DisplayName("getDeckSize should decrease after removeCard triggers refill")
    void getDeckSizeShouldDecreaseAfterRemoveCard() {
        int initialDeckSize = market.getDeckSize(1);
        
        // removeCard should automatically refill from deck
        market.removeCard(1, 0);
        
        // Deck should have decreased by 1 (used for refill)
        assertEquals(initialDeckSize - 1, market.getDeckSize(1));
        
        // Visible should still be 4 (automatically refilled)
        assertEquals(4, market.getVisibleCards(1).size());
    }
    
    // ==================== drawCard() Tests ====================
    
    @Test
    @DisplayName("drawCard should return a card and decrease deck size")
    void drawCardShouldReturnCardAndDecreaseDeck() {
        int initialSize = market.getDeckSize(1);
        
        Card drawn = market.drawCard(1);
        
        assertNotNull(drawn);
        assertEquals(initialSize - 1, market.getDeckSize(1));
    }
    
    @Test
    @DisplayName("drawCard should return null when deck is empty")
    void drawCardShouldReturnNullWhenDeckEmpty() {
        // Draw all cards from level 1 deck
        int deckSize = market.getDeckSize(1);
        for (int i = 0; i < deckSize; i++) {
            assertNotNull(market.drawCard(1));
        }
        
        // Deck should be empty now
        assertEquals(0, market.getDeckSize(1));
        assertNull(market.drawCard(1));
    }
    
    @Test
    @DisplayName("drawCard should return null for invalid level")
    void drawCardShouldReturnNullForInvalidLevel() {
        assertNull(market.drawCard(0));
        assertNull(market.drawCard(4));
        assertNull(market.drawCard(-1));
    }
    
    @Test
    @DisplayName("drawCard should draw different cards each time")
    void drawCardShouldDrawDifferentCards() {
        Card card1 = market.drawCard(1);
        Card card2 = market.drawCard(1);
        Card card3 = market.drawCard(1);
        
        assertNotNull(card1);
        assertNotNull(card2);
        assertNotNull(card3);
        
        // All should be different instances
        assertNotSame(card1, card2);
        assertNotSame(card2, card3);
        assertNotSame(card1, card3);
    }
    
    @Test
    @DisplayName("drawCard should not affect visible cards")
    void drawCardShouldNotAffectVisible() {
        int visibleBefore = market.getVisibleCards(1).size();
        
        market.drawCard(1);
        
        // Visible cards should remain unchanged
        assertEquals(visibleBefore, market.getVisibleCards(1).size());
    }
    
    // ==================== removeCard() Tests (with Auto-Refill) ====================
    
    @Test
    @DisplayName("removeCard should maintain 4 visible cards by auto-refilling")
    void removeCardShouldMaintain4VisibleCards() {
        // Remove a card
        market.removeCard(1, 0);
        
        // Should still have 4 visible (auto-refilled from deck)
        assertEquals(4, market.getVisibleCards(1).size());
    }
    
    @Test
    @DisplayName("removeCard should decrease deck size when refilling")
    void removeCardShouldDecreaseDeckSize() {
        int initialDeckSize = market.getDeckSize(1);
        
        market.removeCard(1, 0);
        
        // Deck used 1 card for refill
        assertEquals(initialDeckSize - 1, market.getDeckSize(1));
    }
    
    @Test
    @DisplayName("removeCard should handle multiple consecutive removals")
    void removeCardShouldHandleMultipleRemovals() {
        int initialDeckSize = market.getDeckSize(1);
        
        // Remove 3 cards
        market.removeCard(1, 0);
        market.removeCard(1, 0);
        market.removeCard(1, 0);
        
        // Still 4 visible (refilled each time)
        assertEquals(4, market.getVisibleCards(1).size());
        
        // Deck decreased by 3
        assertEquals(initialDeckSize - 3, market.getDeckSize(1));
    }
    
    @Test
    @DisplayName("removeCard should not refill when deck is empty")
    void removeCardShouldNotRefillWhenDeckEmpty() {
        // Create market with exactly 4 cards (no deck)
        List<Card> exactly4 = createCards(1, 4);
        List<Card> level2 = createCards(2, 10);
        List<Card> level3 = createCards(3, 10);
        
        CardMarket smallMarket = new CardMarket(exactly4, level2, level3);
        
        assertEquals(4, smallMarket.getVisibleCards(1).size());
        assertEquals(0, smallMarket.getDeckSize(1));
        
        // Remove a card (no deck to refill from)
        smallMarket.removeCard(1, 0);
        
        // Only 3 visible now (can't refill)
        assertEquals(3, smallMarket.getVisibleCards(1).size());
        assertEquals(0, smallMarket.getDeckSize(1));
    }
    
    @Test
    @DisplayName("removeCard should handle partial refill when deck runs low")
    void removeCardShouldHandlePartialRefill() {
        // Create market with 5 total cards (4 visible, 1 in deck)
        List<Card> only5 = createCards(1, 5);
        List<Card> level2 = createCards(2, 10);
        List<Card> level3 = createCards(3, 10);
        
        CardMarket smallMarket = new CardMarket(only5, level2, level3);
        
        assertEquals(4, smallMarket.getVisibleCards(1).size());
        assertEquals(1, smallMarket.getDeckSize(1));
        
        // Remove 1 card (refills with last deck card)
        smallMarket.removeCard(1, 0);
        
        assertEquals(4, smallMarket.getVisibleCards(1).size());
        assertEquals(0, smallMarket.getDeckSize(1));
        
        // Remove another (no refill possible)
        smallMarket.removeCard(1, 0);
        
        assertEquals(3, smallMarket.getVisibleCards(1).size());
        assertEquals(0, smallMarket.getDeckSize(1));
    }
    
    @Test
    @DisplayName("removeCard should not crash on invalid index")
    void removeCardShouldNotCrashOnInvalidIndex() {
        assertDoesNotThrow(() -> market.removeCard(1, -1));
        assertDoesNotThrow(() -> market.removeCard(1, 100));
    }
    
    @Test
    @DisplayName("removeCard should not crash on invalid level")
    void removeCardShouldNotCrashOnInvalidLevel() {
        assertDoesNotThrow(() -> market.removeCard(0, 0));
        assertDoesNotThrow(() -> market.removeCard(4, 0));
    }
    
    @Test
    @DisplayName("removeCard should work independently for each level")
    void removeCardShouldWorkIndependentlyPerLevel() {
        int deck1Before = market.getDeckSize(1);
        int deck2Before = market.getDeckSize(2);
        int deck3Before = market.getDeckSize(3);
        
        // Remove from level 1 only
        market.removeCard(1, 0);
        
        // Only level 1 deck should decrease
        assertEquals(deck1Before - 1, market.getDeckSize(1));
        assertEquals(deck2Before, market.getDeckSize(2));
        assertEquals(deck3Before, market.getDeckSize(3));
        
        // All should still have 4 visible
        assertEquals(4, market.getVisibleCards(1).size());
        assertEquals(4, market.getVisibleCards(2).size());
        assertEquals(4, market.getVisibleCards(3).size());
    }
    
    // ==================== Integration Tests ====================
    
    @Test
    @DisplayName("Full workflow: remove card (auto-refills), draw, repeat")
    void fullWorkflowRemoveAndDraw() {
        int initialDeckSize = market.getDeckSize(1);
        
        // Step 1: Remove a card (auto-refills)
        market.removeCard(1, 0);
        assertEquals(4, market.getVisibleCards(1).size());
        assertEquals(initialDeckSize - 1, market.getDeckSize(1));
        
        // Step 2: Draw a card (doesn't affect visible)
        Card drawn = market.drawCard(1);
        assertNotNull(drawn);
        assertEquals(4, market.getVisibleCards(1).size());
        assertEquals(initialDeckSize - 2, market.getDeckSize(1));
        
        // Step 3: Remove another (auto-refills again)
        market.removeCard(1, 2);
        assertEquals(4, market.getVisibleCards(1).size());
        assertEquals(initialDeckSize - 3, market.getDeckSize(1));
    }
    
    @Test
    @DisplayName("Market should handle complete depletion with auto-refill")
    void marketShouldHandleCompleteDepletionWithAutoRefill() {
        // Remove cards until deck is depleted
        int totalCards = 10;  // 4 visible + 6 deck
        
        // Remove 6 cards (each refills from deck)
        for (int i = 0; i < 6; i++) {
            market.removeCard(1, 0);
            assertEquals(4, market.getVisibleCards(1).size());
        }
        
        // Deck should now be empty
        assertEquals(0, market.getDeckSize(1));
        assertEquals(4, market.getVisibleCards(1).size());
        
        // Remove more cards (no refill possible)
        market.removeCard(1, 0);
        assertEquals(3, market.getVisibleCards(1).size());
        
        market.removeCard(1, 0);
        assertEquals(2, market.getVisibleCards(1).size());
        
        market.removeCard(1, 0);
        assertEquals(1, market.getVisibleCards(1).size());
        
        market.removeCard(1, 0);
        assertEquals(0, market.getVisibleCards(1).size());
    }
    
    @Test
    @DisplayName("All three levels should operate independently with auto-refill")
    void allLevelsShouldOperateIndependentlyWithAutoRefill() {
        // Modify level 1
        market.removeCard(1, 0);
        
        // Modify level 2
        market.drawCard(2);
        market.drawCard(2);
        
        // Modify level 3
        market.removeCard(3, 1);
        market.removeCard(3, 1);
        
        // Check independence
        assertEquals(4, market.getVisibleCards(1).size());  // Auto-refilled
        assertEquals(5, market.getDeckSize(1));             // Used 1 for refill
        
        assertEquals(4, market.getVisibleCards(2).size());  // Unchanged
        assertEquals(4, market.getDeckSize(2));             // Drew 2
        
        assertEquals(4, market.getVisibleCards(3).size());  // Auto-refilled twice
        assertEquals(4, market.getDeckSize(3));             // Used 2 for refill
    }
    
    @Test
    @DisplayName("Removing all 4 visible cards rapidly should maintain refill")
    void removingAll4VisibleShouldMaintainRefill() {
        int initialDeck = market.getDeckSize(1);
        
        // Remove all 4 visible cards in succession
        market.removeCard(1, 0);
        market.removeCard(1, 0);
        market.removeCard(1, 0);
        market.removeCard(1, 0);
        
        // Should still have 4 visible (refilled 4 times)
        assertEquals(4, market.getVisibleCards(1).size());
        
        // Deck should have used 4 cards
        assertEquals(initialDeck - 4, market.getDeckSize(1));
    }
    
    // ==================== Edge Case Tests ====================
    
    @Test
    @DisplayName("Should handle large number of cards with auto-refill")
    void shouldHandleLargeNumberOfCardsWithAutoRefill() {
        List<Card> large1 = createCards(1, 100);
        List<Card> large2 = createCards(2, 100);
        List<Card> large3 = createCards(3, 100);
        
        CardMarket largeMarket = new CardMarket(large1, large2, large3);
        
        assertEquals(4, largeMarket.getVisibleCards(1).size());
        assertEquals(96, largeMarket.getDeckSize(1));
        
        // Remove 50 cards (should auto-refill each time)
        for (int i = 0; i < 50; i++) {
            largeMarket.removeCard(1, 0);
        }
        
        assertEquals(4, largeMarket.getVisibleCards(1).size());
        assertEquals(46, largeMarket.getDeckSize(1));  // 96 - 50 = 46
    }
    
    @Test
    @DisplayName("Should handle single card per level with auto-refill attempt")
    void shouldHandleSingleCardPerLevelWithAutoRefill() {
        List<Card> single1 = createCards(1, 1);
        List<Card> single2 = createCards(2, 1);
        List<Card> single3 = createCards(3, 1);
        
        CardMarket singleMarket = new CardMarket(single1, single2, single3);
        
        assertEquals(1, singleMarket.getVisibleCards(1).size());
        assertEquals(0, singleMarket.getDeckSize(1));
        
        // Remove the only card (can't refill)
        singleMarket.removeCard(1, 0);
        
        assertEquals(0, singleMarket.getVisibleCards(1).size());
        assertEquals(0, singleMarket.getDeckSize(1));
    }
}