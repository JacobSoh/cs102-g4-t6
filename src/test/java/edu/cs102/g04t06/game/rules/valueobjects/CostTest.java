package edu.cs102.g04t06.game.rules.valueobjects;

import edu.cs102.g04t06.game.rules.entities.GemColor;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;

import java.util.EnumMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
// Generated by Claude Sonnet 4.5
/**
 * Unit tests for Cost value object.
 * 
 * @author CS102 Team G6
 * @version 1.0
 */
@DisplayName("Cost Tests")
class CostTest {
    
    private Map<GemColor, Integer> standardCostMap;
    private Cost standardCost;
    
    @BeforeEach
    void setUp() {
        // Standard cost: 3 white, 2 blue, 1 green
        standardCostMap = new EnumMap<>(GemColor.class);
        standardCostMap.put(GemColor.WHITE, 3);
        standardCostMap.put(GemColor.BLUE, 2);
        standardCostMap.put(GemColor.GREEN, 1);
        
        standardCost = new Cost(standardCostMap);
    }
    
    // ==================== Constructor Tests ====================
    
    @Test
    @DisplayName("Constructor should create cost with correct values")
    void constructorShouldCreateCostCorrectly() {
        assertEquals(3, standardCost.getRequired(GemColor.WHITE));
        assertEquals(2, standardCost.getRequired(GemColor.BLUE));
        assertEquals(1, standardCost.getRequired(GemColor.GREEN));
    }
    
    @Test
    @DisplayName("Constructor should make defensive copy")
    void constructorShouldMakeDefensiveCopy() {
        Map<GemColor, Integer> original = new EnumMap<>(GemColor.class);
        original.put(GemColor.WHITE, 5);
        
        Cost cost = new Cost(original);
        
        // Modify original map
        original.put(GemColor.WHITE, 999);
        original.put(GemColor.RED, 100);
        
        // Cost should be unchanged
        assertEquals(5, cost.getRequired(GemColor.WHITE));
        assertEquals(0, cost.getRequired(GemColor.RED));
    }
    
    @Test
    @DisplayName("Constructor should handle empty cost map")
    void constructorShouldHandleEmptyCost() {
        Map<GemColor, Integer> emptyCost = new EnumMap<>(GemColor.class);
        Cost cost = new Cost(emptyCost);
        
        assertEquals(0, cost.getTotalGems());
        assertEquals(0, cost.getRequired(GemColor.WHITE));
    }
    
    // ==================== getRequired() Tests ====================
    
    @Test
    @DisplayName("getRequired should return correct amount for existing color")
    void getRequiredShouldReturnCorrectAmount() {
        assertEquals(3, standardCost.getRequired(GemColor.WHITE));
        assertEquals(2, standardCost.getRequired(GemColor.BLUE));
        assertEquals(1, standardCost.getRequired(GemColor.GREEN));
    }
    
    @Test
    @DisplayName("getRequired should return 0 for non-existent color")
    void getRequiredShouldReturnZeroForMissingColor() {
        assertEquals(0, standardCost.getRequired(GemColor.RED));
        assertEquals(0, standardCost.getRequired(GemColor.BLACK));
        assertEquals(0, standardCost.getRequired(GemColor.GOLD));
    }
    
    // ==================== getTotalGems() Tests ====================
    
    @Test
    @DisplayName("getTotalGems should sum all gem requirements")
    void getTotalGemsShouldSumAllRequirements() {
        // 3 white + 2 blue + 1 green = 6
        assertEquals(6, standardCost.getTotalGems());
    }
    
    @Test
    @DisplayName("getTotalGems should return 0 for empty cost")
    void getTotalGemsShouldReturnZeroForEmptyCost() {
        Cost emptyCost = new Cost(new EnumMap<>(GemColor.class));
        assertEquals(0, emptyCost.getTotalGems());
    }
    
    @Test
    @DisplayName("getTotalGems should handle single gem cost")
    void getTotalGemsShouldHandleSingleGem() {
        Map<GemColor, Integer> singleGem = new EnumMap<>(GemColor.class);
        singleGem.put(GemColor.RED, 4);
        
        Cost cost = new Cost(singleGem);
        assertEquals(4, cost.getTotalGems());
    }
    
    // ==================== asMap() Tests ====================
    
    @Test
    @DisplayName("asMap should return defensive copy")
    void asMapShouldReturnDefensiveCopy() {
        Map<GemColor, Integer> retrieved = standardCost.asMap();
        
        // Modify retrieved map
        retrieved.put(GemColor.WHITE, 999);
        retrieved.put(GemColor.RED, 100);
        
        // Original cost should be unchanged
        assertEquals(3, standardCost.getRequired(GemColor.WHITE));
        assertEquals(0, standardCost.getRequired(GemColor.RED));
    }
    
    @Test
    @DisplayName("asMap should return correct values")
    void asMapShouldReturnCorrectValues() {
        Map<GemColor, Integer> retrieved = standardCost.asMap();
        
        assertEquals(3, retrieved.get(GemColor.WHITE));
        assertEquals(2, retrieved.get(GemColor.BLUE));
        assertEquals(1, retrieved.get(GemColor.GREEN));
    }
    
    // ==================== afterBonuses() Tests ====================
    
    @Test
    @DisplayName("afterBonuses should subtract bonuses from cost")
    void afterBonusesShouldSubtractBonuses() {
        Map<GemColor, Integer> bonuses = new EnumMap<>(GemColor.class);
        bonuses.put(GemColor.WHITE, 1);  // Player has 1 white bonus
        bonuses.put(GemColor.BLUE, 1);   // Player has 1 blue bonus
        
        Cost actualCost = standardCost.afterBonuses(bonuses);
        
        // White: 3 - 1 = 2
        // Blue: 2 - 1 = 1
        // Green: 1 - 0 = 1
        assertEquals(2, actualCost.getRequired(GemColor.WHITE));
        assertEquals(1, actualCost.getRequired(GemColor.BLUE));
        assertEquals(1, actualCost.getRequired(GemColor.GREEN));
        assertEquals(4, actualCost.getTotalGems());
    }
    
    @Test
    @DisplayName("afterBonuses should fully cover cost if bonuses sufficient")
    void afterBonusesShouldFullyCoverCost() {
        Map<GemColor, Integer> bonuses = new EnumMap<>(GemColor.class);
        bonuses.put(GemColor.WHITE, 5);  // More than needed
        bonuses.put(GemColor.BLUE, 5);
        bonuses.put(GemColor.GREEN, 5);
        
        Cost actualCost = standardCost.afterBonuses(bonuses);
        
        // All costs should be 0 (fully covered)
        assertEquals(0, actualCost.getRequired(GemColor.WHITE));
        assertEquals(0, actualCost.getRequired(GemColor.BLUE));
        assertEquals(0, actualCost.getRequired(GemColor.GREEN));
        assertEquals(0, actualCost.getTotalGems());
    }
    
    @Test
    @DisplayName("afterBonuses should not go negative")
    void afterBonusesShouldNotGoNegative() {
        Map<GemColor, Integer> bonuses = new EnumMap<>(GemColor.class);
        bonuses.put(GemColor.WHITE, 10);  // Way more than cost
        
        Cost actualCost = standardCost.afterBonuses(bonuses);
        
        // Should be 0, not negative
        assertEquals(0, actualCost.getRequired(GemColor.WHITE));
        assertTrue(actualCost.getRequired(GemColor.WHITE) >= 0);
    }
    
    @Test
    @DisplayName("afterBonuses should handle no bonuses")
    void afterBonusesShouldHandleNoBonuses() {
        Map<GemColor, Integer> noBonuses = new EnumMap<>(GemColor.class);
        
        Cost actualCost = standardCost.afterBonuses(noBonuses);
        
        // Cost should remain unchanged
        assertEquals(3, actualCost.getRequired(GemColor.WHITE));
        assertEquals(2, actualCost.getRequired(GemColor.BLUE));
        assertEquals(1, actualCost.getRequired(GemColor.GREEN));
        assertEquals(6, actualCost.getTotalGems());
    }
    
    @Test
    @DisplayName("afterBonuses should only reduce relevant colors")
    void afterBonusesShouldOnlyReduceRelevantColors() {
        Map<GemColor, Integer> bonuses = new EnumMap<>(GemColor.class);
        bonuses.put(GemColor.RED, 5);    // Card doesn't cost red
        bonuses.put(GemColor.BLACK, 5);  // Card doesn't cost black
        bonuses.put(GemColor.WHITE, 1);  // Only this applies
        
        Cost actualCost = standardCost.afterBonuses(bonuses);
        
        assertEquals(2, actualCost.getRequired(GemColor.WHITE));  // 3 - 1
        assertEquals(2, actualCost.getRequired(GemColor.BLUE));   // Unchanged
        assertEquals(1, actualCost.getRequired(GemColor.GREEN));  // Unchanged
    }
    
    @Test
    @DisplayName("afterBonuses should not include fully covered colors in result")
    void afterBonusesShouldExcludeFullyCoveredColors() {
        Map<GemColor, Integer> bonuses = new EnumMap<>(GemColor.class);
        bonuses.put(GemColor.BLUE, 2);   // Exactly covers blue cost
        
        Cost actualCost = standardCost.afterBonuses(bonuses);
        
        Map<GemColor, Integer> resultMap = actualCost.asMap();
        
        // Blue should not be in the result (fully covered)
        assertFalse(resultMap.containsKey(GemColor.BLUE) && resultMap.get(GemColor.BLUE) > 0);
        
        // White and green should still be there
        assertTrue(resultMap.containsKey(GemColor.WHITE));
        assertTrue(resultMap.containsKey(GemColor.GREEN));
    }
    
    // ==================== Immutability Tests ====================
    
    @Test
    @DisplayName("Original cost should remain unchanged after afterBonuses")
    void originalCostShouldRemainUnchangedAfterBonuses() {
        Map<GemColor, Integer> bonuses = new EnumMap<>(GemColor.class);
        bonuses.put(GemColor.WHITE, 2);
        
        Cost actualCost = standardCost.afterBonuses(bonuses);
        
        // Original should be unchanged
        assertEquals(3, standardCost.getRequired(GemColor.WHITE));
        assertEquals(6, standardCost.getTotalGems());
        
        // New cost should be different
        assertEquals(1, actualCost.getRequired(GemColor.WHITE));
        assertEquals(4, actualCost.getTotalGems());
    }
    
    @Test
    @DisplayName("Cost should be immutable - asMap modification doesn't affect cost")
    void costShouldBeImmutableViaAsMap() {
        Map<GemColor, Integer> retrieved1 = standardCost.asMap();
        retrieved1.clear();
        
        Map<GemColor, Integer> retrieved2 = standardCost.asMap();
        
        // Should still have original values
        assertEquals(3, retrieved2.get(GemColor.WHITE));
        assertEquals(3, standardCost.getRequired(GemColor.WHITE));
    }
    
    // ==================== Edge Case Tests ====================
    
    @Test
    @DisplayName("Should handle zero cost for a color")
    void shouldHandleZeroCostColor() {
        Map<GemColor, Integer> costMap = new EnumMap<>(GemColor.class);
        costMap.put(GemColor.WHITE, 0);
        costMap.put(GemColor.BLUE, 2);
        
        Cost cost = new Cost(costMap);
        
        assertEquals(0, cost.getRequired(GemColor.WHITE));
        assertEquals(2, cost.getTotalGems());
    }
    
    @Test
    @DisplayName("Should handle all gem colors in cost")
    void shouldHandleAllGemColors() {
        Map<GemColor, Integer> costMap = new EnumMap<>(GemColor.class);
        costMap.put(GemColor.WHITE, 1);
        costMap.put(GemColor.BLUE, 1);
        costMap.put(GemColor.GREEN, 1);
        costMap.put(GemColor.RED, 1);
        costMap.put(GemColor.BLACK, 1);
        // Note: GOLD typically not in card costs
        
        Cost cost = new Cost(costMap);
        
        assertEquals(5, cost.getTotalGems());
        assertEquals(1, cost.getRequired(GemColor.WHITE));
        assertEquals(1, cost.getRequired(GemColor.BLACK));
    }
    
    @Test
    @DisplayName("Should handle very high cost values")
    void shouldHandleHighCostValues() {
        Map<GemColor, Integer> costMap = new EnumMap<>(GemColor.class);
        costMap.put(GemColor.WHITE, 100);
        
        Cost cost = new Cost(costMap);
        
        assertEquals(100, cost.getRequired(GemColor.WHITE));
        assertEquals(100, cost.getTotalGems());
        
        // Bonuses should still work
        Map<GemColor, Integer> bonuses = new EnumMap<>(GemColor.class);
        bonuses.put(GemColor.WHITE, 50);
        
        Cost afterBonuses = cost.afterBonuses(bonuses);
        assertEquals(50, afterBonuses.getRequired(GemColor.WHITE));
    }
}